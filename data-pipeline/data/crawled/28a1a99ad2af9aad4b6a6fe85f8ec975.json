{
    "id": "28a1a99ad2af9aad4b6a6fe85f8ec975",
    "metadata": {
        "id": "28a1a99ad2af9aad4b6a6fe85f8ec975",
        "url": "https://huggingface.co/blog/moe/",
        "title": "Mixture of Experts Explained",
        "properties": {
            "description": "We’re on a journey to advance and democratize artificial intelligence through open source and open science.",
            "keywords": null,
            "author": null,
            "og:title": "Mixture of Experts Explained",
            "og:type": "website",
            "og:url": "https://huggingface.co/blog/moe",
            "og:image": "https://huggingface.co/blog/assets/moe/thumbnail.png",
            "twitter:card": "summary_large_image",
            "twitter:site": "@huggingface",
            "twitter:image": "https://huggingface.co/blog/assets/moe/thumbnail.png"
        }
    },
    "parent_metadata": {
        "id": "b1c2e810a2668d637eebdde3fe5a7cd8",
        "url": "https://www.notion.so/LLMs-b1c2e810a2668d637eebdde3fe5a7cd8",
        "title": "LLMs",
        "properties": {
            "Type": "Leaf"
        }
    },
    "content": "[![Hugging Face's logo](/front/assets/huggingface_logo-noborder.svg) Hugging Face](/)\n\n  * [ Models](/models)\n  * [ Datasets](/datasets)\n  * [ Spaces](/spaces)\n  * [ Posts](/posts)\n  * [ Docs](/docs)\n  * [ Enterprise](/enterprise)\n  * [Pricing](/pricing)\n  * [Log In](/login)\n  * [Sign Up](/join)\n\n\n\n[ Back to Articles](/blog)\n\n#  [ ](#mixture-of-experts-explained) Mixture of Experts Explained \n\nPublished December 11, 2023\n\n[Update on GitHub](https://github.com/huggingface/blog/blob/main/moe.md)\n\n[ Upvote 262 ](/login?next=%2Fblog%2Fmoe)\n\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1583857146757-5e67bdd61009063689407479.jpeg)](/clem \"clem\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1585493970035-noauth.jpeg)](/maveriq \"maveriq\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/5edf9030636bdb3834e2da08/At8kxNZmG7ZWuxx7P3dlM.png)](/erinkhoo \"erinkhoo\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1594311341799-5f07383b19cb630495b812cd.jpeg)](/stas \"stas\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/5f43448a79c1ba4c353d0d8f/DiSygV3dn7A_OjmGVTrHD.jpeg)](/sugatoray \"sugatoray\")\n  * [![](/avatars/42b34eda17abafaba2c96906cecc9c73.svg)](/Shivangsharma \"Shivangsharma\")\n  * +256\n\n\n\n[![Omar Sanseviero's avatar](https://cdn-avatars.huggingface.co/v1/production/uploads/6032802e1f993496bc14d9e3/w6hr-DEQot4VVkoyRIBiy.png) osanseviero Omar Sanseviero ](/osanseviero) [![Lewis Tunstall's avatar](https://cdn-avatars.huggingface.co/v1/production/uploads/1594651707950-noauth.jpeg) lewtun Lewis Tunstall ](/lewtun) [![Philipp Schmid's avatar](https://cdn-avatars.huggingface.co/v1/production/uploads/1624629516652-5ff5d596f244529b3ec0fb89.png) philschmid Philipp Schmid ](/philschmid) [![Sourab Mangrulkar's avatar](https://cdn-avatars.huggingface.co/v1/production/uploads/1638132956881-5fca176d1d7a08cb34d79d5d.jpeg) smangrul Sourab Mangrulkar ](/smangrul) [![Younes Belkada's avatar](https://cdn-avatars.huggingface.co/v1/production/uploads/1648631057413-noauth.png) ybelkada Younes Belkada ](/ybelkada) [![Pedro Cuenca's avatar](https://cdn-avatars.huggingface.co/v1/production/uploads/1617264212503-603d25b75f9d390ab190b777.jpeg) pcuenq Pedro Cuenca ](/pcuenq)\n\n  * [Table of Contents](#table-of-contents \"Table of Contents\")\n  * [TL;DR](#tldr \"TL;DR\")\n  * [What is a Mixture of Experts (MoE)?](#what-is-a-mixture-of-experts-moe \"What is a Mixture of Experts \\(MoE\\)?\")\n  * [A Brief History of MoEs](#a-brief-history-of-moes \"A Brief History of MoEs\")\n  * [What is Sparsity?](#what-is-sparsity \"What is Sparsity?\")\n  * [Load balancing tokens for MoEs](#load-balancing-tokens-for-moes \"Load balancing tokens for MoEs\")\n  * [MoEs and Transformers](#moes-and-transformers \"MoEs and Transformers\")\n  * [Switch Transformers](#switch-transformers \"Switch Transformers\")\n  * [Stabilizing training with router Z-loss](#stabilizing-training-with-router-z-loss \"Stabilizing training with router Z-loss\")\n  * [What does an expert learn?](#what-does-an-expert-learn \"What does an expert learn?\")\n  * [How does scaling the number of experts impact pretraining?](#how-does-scaling-the-number-of-experts-impact-pretraining \"How does scaling the number of experts impact pretraining?\")\n  * [Fine-tuning MoEs](#fine-tuning-moes \"Fine-tuning MoEs\")\n  * [When to use sparse MoEs vs dense models?](#when-to-use-sparse-moes-vs-dense-models \"When to use sparse MoEs vs dense models?\")\n  * [Making MoEs go brrr](#making-moes-go-brrr \"Making MoEs go brrr\")\n    * [Parallelism](#parallelism \"Parallelism\")\n    * [Capacity Factor and communication costs](#capacity-factor-and-communication-costs \"Capacity Factor and communication costs\")\n    * [Serving techniques](#serving-techniques \"Serving techniques\")\n    * [More on efficient training](#more-on-efficient-training \"More on efficient training\")\n  * [Open Source MoEs](#open-source-moes \"Open Source MoEs\")\n  * [Exciting directions of work](#exciting-directions-of-work \"Exciting directions of work\")\n  * [Some resources](#some-resources \"Some resources\")\n  * [Citation](#citation \"Citation\")\n\n\n\nWith the release of Mixtral 8x7B ([announcement](https://mistral.ai/news/mixtral-of-experts/), [model card](https://huggingface.co/mistralai/Mixtral-8x7B-v0.1)), a class of transformer has become the hottest topic in the open AI community: Mixture of Experts, or MoEs for short. In this blog post, we take a look at the building blocks of MoEs, how they’re trained, and the tradeoffs to consider when serving them for inference. \n\nLet’s dive in!\n\n##  [ ](#table-of-contents) Table of Contents \n\n  * [What is a Mixture of Experts?](#what-is-a-mixture-of-experts-moe)\n  * [A Brief History of MoEs](#a-brief-history-of-moes)\n  * [What is Sparsity?](#what-is-sparsity)\n  * [Load Balancing tokens for MoEs](#load-balancing-tokens-for-moes)\n  * [MoEs and Transformers](#moes-and-transformers)\n  * [Switch Transformers](#switch-transformers)\n  * [Stabilizing training with router Z-loss](#stabilizing-training-with-router-z-loss)\n  * [What does an expert learn?](#what-does-an-expert-learn)\n  * [How does scaling the number of experts impact pretraining?](#how-does-scaling-the-number-of-experts-impact-pretraining)\n  * [Fine-tuning MoEs](#fine-tuning-moes)\n  * [When to use sparse MoEs vs dense models?](#when-to-use-sparse-moes-vs-dense-models)\n  * [Making MoEs go brrr](#making-moes-go-brrr)\n    * [Expert Parallelism](#parallelism)\n    * [Capacity Factor and Communication costs](#capacity-factor-and-communication-costs)\n    * [Serving Techniques](#serving-techniques)\n    * [Efficient Training](#more-on-efficient-training)\n  * [Open Source MoEs](#open-source-moes)\n  * [Exciting directions of work](#exciting-directions-of-work)\n  * [Some resources](#some-resources)\n\n\n\n##  [ ](#tldr) TL;DR \n\nMoEs:\n\n  * Are **pretrained much faster** vs. dense models\n  * Have **faster inference** compared to a model with the same number of parameters\n  * Require **high VRAM** as all experts are loaded in memory\n  * Face many **challenges in fine-tuning** , but [recent work](https://arxiv.org/pdf/2305.14705.pdf) with MoE **instruction-tuning is promising**\n\n\n\nLet’s dive in!\n\n##  [ ](#what-is-a-mixture-of-experts-moe) What is a Mixture of Experts (MoE)? \n\nThe scale of a model is one of the most important axes for better model quality. Given a fixed computing budget, training a larger model for fewer steps is better than training a smaller model for more steps. \n\nMixture of Experts enable models to be pretrained with far less compute, which means you can dramatically scale up the model or dataset size with the same compute budget as a dense model. In particular, a MoE model should achieve the same quality as its dense counterpart much faster during pretraining. \n\nSo, what exactly is a MoE? In the context of transformer models, a MoE consists of two main elements:\n\n  * **Sparse MoE layers** are used instead of dense feed-forward network (FFN) layers. MoE layers have a certain number of “experts” (e.g. 8), where each expert is a neural network. In practice, the experts are FFNs, but they can also be more complex networks or even a MoE itself, leading to hierarchical MoEs!\n  * A **gate network or router** , that determines which tokens are sent to which expert. For example, in the image below, the token “More” is sent to the second expert, and the token \"Parameters” is sent to the first network. As we’ll explore later, we can send a token to more than one expert. How to route a token to an expert is one of the big decisions when working with MoEs - the router is composed of learned parameters and is pretrained at the same time as the rest of the network.\n\n![Switch Layer](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/00_switch_transformer.png) MoE layer from the [Switch Transformers paper](https://arxiv.org/abs/2101.03961)\n\nSo, to recap, in MoEs we replace every FFN layer of the transformer model with an MoE layer, which is composed of a gate network and a certain number of experts.\n\nAlthough MoEs provide benefits like efficient pretraining and faster inference compared to dense models, they also come with challenges:\n\n  * **Training:** MoEs enable significantly more compute-efficient pretraining, but they’ve historically struggled to generalize during fine-tuning, leading to overfitting.\n  * **Inference:** Although a MoE might have many parameters, only some of them are used during inference. This leads to much faster inference compared to a dense model with the same number of parameters. However, all parameters need to be loaded in RAM, so memory requirements are high. For example, given a MoE like Mixtral 8x7B, we’ll need to have enough VRAM to hold a dense 47B parameter model. Why 47B parameters and not 8 x 7B = 56B? That’s because in MoE models, only the FFN layers are treated as individual experts, and the rest of the model parameters are shared. At the same time, assuming just two experts are being used per token, the inference speed (FLOPs) is like using a 12B model (as opposed to a 14B model), because it computes 2x7B matrix multiplications, but with some layers shared (more on this soon).\n\n\n\nNow that we have a rough idea of what a MoE is, let’s take a look at the research developments that led to their invention.\n\n##  [ ](#a-brief-history-of-moes) A Brief History of MoEs \n\nThe roots of MoEs come from the 1991 paper [Adaptive Mixture of Local Experts](https://www.cs.toronto.edu/~hinton/absps/jjnh91.pdf). The idea, akin to ensemble methods, was to have a supervised procedure for a system composed of separate networks, each handling a different subset of the training cases. Each separate network, or expert, specializes in a different region of the input space. How is the expert chosen? A gating network determines the weights for each expert. During training, both the expert and the gating are trained.\n\nBetween 2010-2015, two different research areas contributed to later MoE advancement:\n\n  * **Experts as components** : In the traditional MoE setup, the whole system comprises a gating network and multiple experts. MoEs as the whole model have been explored in SVMs, Gaussian Processes, and other methods. The work by [Eigen, Ranzato, and Ilya](https://arxiv.org/abs/1312.4314) explored MoEs as components of deeper networks. This allows having MoEs as layers in a multilayer network, making it possible for the model to be both large and efficient simultaneously.\n  * **Conditional Computation** : Traditional networks process all input data through every layer. In this period, Yoshua Bengio researched approaches to dynamically activate or deactivate components based on the input token.\n\n\n\nThese works led to exploring a mixture of experts in the context of NLP. Concretely, [Shazeer et al.](https://arxiv.org/abs/1701.06538) (2017, with “et al.” including Geoffrey Hinton and Jeff Dean, [Google’s Chuck Norris](https://www.informatika.bg/jeffdean)) scaled this idea to a 137B LSTM (the de-facto NLP architecture back then, created by Schmidhuber) by introducing sparsity, allowing to keep very fast inference even at high scale. This work focused on translation but faced many challenges, such as high communication costs and training instabilities.\n\n![MoE layer in LSTM](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/01_moe_layer.png) MoE layer from the Outrageously Large Neural Network paper\n\nMoEs have allowed training multi-trillion parameter models, such as the open-sourced 1.6T parameters Switch Transformers, among others. MoEs have also been explored in Computer Vision, but this blog post will focus on the NLP domain.\n\n##  [ ](#what-is-sparsity) What is Sparsity? \n\nSparsity uses the idea of conditional computation. While in dense models all the parameters are used for all the inputs, sparsity allows us to only run some parts of the whole system.\n\nLet’s dive deeper into Shazeer's exploration of MoEs for translation. The idea of conditional computation (parts of the network are active on a per-example basis) allows one to scale the size of the model without increasing the computation, and hence, this led to thousands of experts being used in each MoE layer.\n\nThis setup introduces some challenges. For example, although large batch sizes are usually better for performance, batch sizes in MOEs are effectively reduced as data flows through the active experts. For example, if our batched input consists of 10 tokens, **five tokens might end in one expert, and the other five tokens might end in five different experts, leading to uneven batch sizes and underutilization**. The [Making MoEs go brrr](#making-moes-go-brrr) section below will discuss other challenges and solutions.\n\nHow can we solve this? A learned gating network (G) decides which experts (E) to send a part of the input:\n\ny=∑i=1nG(x)iEi(x) y = \\sum_{i=1}^{n} G(x)_i E_i(x) y=i=1∑n​G(x)i​Ei​(x)\n\nIn this setup, all experts are run for all inputs - it’s a weighted multiplication. But, what happens if G is 0? If that’s the case, there’s no need to compute the respective expert operations and hence we save compute. What’s a typical gating function? In the most traditional setup, we just use a simple network with a softmax function. The network will learn which expert to send the input.\n\nGσ(x)=Softmax(x⋅Wg) G_\\sigma(x) = \\text{Softmax}(x \\cdot W_g) Gσ​(x)=Softmax(x⋅Wg​)\n\nShazeer’s work also explored other gating mechanisms, such as Noisy Top-k Gating. This gating approach introduces some (tunable) noise and then keeps the top k values. That is:\n\n  1. We add some noise\n\n\n\nH(x)i=(x⋅Wg)i+StandardNormal()⋅Softplus((x⋅Wnoise)i) H(x)_i = (x \\cdot W_{\\text{g}})_i + \\text{StandardNormal()} \\cdot \\text{Softplus}((x \\cdot W_{\\text{noise}})_i) H(x)i​=(x⋅Wg​)i​+StandardNormal()⋅Softplus((x⋅Wnoise​)i​)\n\n  1. We only pick the top k\n\n\n\nKeepTopK(v,k)i={viif vi is in the top k elements of v,−∞otherwise. \\text{KeepTopK}(v, k)_i = \\begin{cases} v_i & \\text{if } v_i \\text{ is in the top } k \\text{ elements of } v, \\\\\\ -\\infty & \\text{otherwise.} \\end{cases} KeepTopK(v,k)i​={vi​−∞​if vi​ is in the top k elements of v,otherwise.​\n\n  1. We apply the softmax.\n\n\n\nG(x)=Softmax(KeepTopK(H(x),k)) G(x) = \\text{Softmax}(\\text{KeepTopK}(H(x), k)) G(x)=Softmax(KeepTopK(H(x),k))\n\nThis sparsity introduces some interesting properties. By using a low enough k (e.g. one or two), we can train and run inference much faster than if many experts were activated. Why not just select the top expert? The initial conjecture was that routing to more than one expert was needed to have the gate learn how to route to different experts, so at least two experts had to be picked. The [Switch Transformers](#switch-transformers) section revisits this decision.\n\nWhy do we add noise? That’s for load balancing!\n\n##  [ ](#load-balancing-tokens-for-moes) Load balancing tokens for MoEs \n\nAs discussed before, if all our tokens are sent to just a few popular experts, that will make training inefficient. In a normal MoE training, the gating network converges to mostly activate the same few experts. This self-reinforces as favored experts are trained quicker and hence selected more. To mitigate this, an **auxiliary loss** is added to encourage giving all experts equal importance. This loss ensures that all experts receive a roughly equal number of training examples. The following sections will also explore the concept of expert capacity, which introduces a threshold of how many tokens can be processed by an expert. In `transformers`, the auxiliary loss is exposed via the `aux_loss` parameter.\n\n##  [ ](#moes-and-transformers) MoEs and Transformers \n\nTransformers are a very clear case that scaling up the number of parameters improves the performance, so it’s not surprising that Google explored this with [GShard](https://arxiv.org/abs/2006.16668), which explores scaling up transformers beyond 600 billion parameters.\n\nGShard replaces every other FFN layer with an MoE layer using top-2 gating in both the encoder and the decoder. The next image shows how this looks like for the encoder part. This setup is quite beneficial for large-scale computing: when we scale to multiple devices, the MoE layer is shared across devices while all the other layers are replicated. This is further discussed in the [“Making MoEs go brrr”](#making-moes-go-brrr) section.\n\n![MoE Transformer Encoder](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/02_moe_block.png) MoE Transformer Encoder from the GShard Paper\n\nTo maintain a balanced load and efficiency at scale, the GShard authors introduced a couple of changes in addition to an auxiliary loss similar to the one discussed in the previous section:\n\n  * **Random routing** : in a top-2 setup, we always pick the top expert, but the second expert is picked with probability proportional to its weight.\n  * **Expert capacity** : we can set a threshold of how many tokens can be processed by one expert. If both experts are at capacity, the token is considered overflowed, and it’s sent to the next layer via residual connections (or dropped entirely in other projects). This concept will become one of the most important concepts for MoEs. Why is expert capacity needed? Since all tensor shapes are statically determined at compilation time, but we cannot know how many tokens will go to each expert ahead of time, we need to fix the capacity factor.\n\n\n\nThe GShard paper has contributions by expressing parallel computation patterns that work well for MoEs, but discussing that is outside the scope of this blog post.\n\n**Note:** when we run inference, only some experts will be triggered. At the same time, there are shared computations, such as self-attention, which is applied for all tokens. That’s why when we talk of a 47B model of 8 experts, we can run with the compute of a 12B dense model. If we use top-2, 14B parameters would be used. But given that the attention operations are shared (among others), the actual number of used parameters is 12B.\n\n##  [ ](#switch-transformers) Switch Transformers \n\nAlthough MoEs showed a lot of promise, they struggle with training and fine-tuning instabilities. [Switch Transformers](https://arxiv.org/abs/2101.03961) is a very exciting work that deep dives into these topics. The authors even released a [1.6 trillion parameters MoE on Hugging Face](https://huggingface.co/google/switch-c-2048) with 2048 experts, which you can run with transformers. Switch Transformers achieved a 4x pre-train speed-up over T5-XXL.\n\n![Switch Transformer Layer](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/03_switch_layer.png) Switch Transformer Layer of the Switch Transformer paper\n\nJust as in GShard, the authors replaced the FFN layers with a MoE layer. The Switch Transformers paper proposes a Switch Transformer layer that receives two inputs (two different tokens) and has four experts.\n\nContrary to the initial idea of using at least two experts, Switch Transformers uses a simplified single-expert strategy. The effects of this approach are:\n\n  * The router computation is reduced\n  * The batch size of each expert can be at least halved\n  * Communication costs are reduced\n  * Quality is preserved\n\n\n\nSwitch Transformers also explores the concept of expert capacity. \n\nExpert Capacity=(tokens per batchnumber of experts)×capacity factor \\text{Expert Capacity} = \\left(\\frac{\\text{tokens per batch}}{\\text{number of experts}}\\right) \\times \\text{capacity factor} Expert Capacity=(number of expertstokens per batch​)×capacity factor\n\nThe capacity suggested above evenly divides the number of tokens in the batch across the number of experts. If we use a capacity factor greater than 1, we provide a buffer for when tokens are not perfectly balanced. Increasing the capacity will lead to more expensive inter-device communication, so it’s a trade-off to keep in mind. In particular, Switch Transformers perform well at low capacity factors (1-1.25)\n\nSwitch Transformer authors also revisit and simplify the load balancing loss mentioned in the sections. For each Switch layer, the auxiliary loss is added to the total model loss during training. This loss encourages uniform routing and can be weighted using a hyperparameter.\n\nThe authors also experiment with selective precision, such as training the experts with `bfloat16` while using full precision for the rest of the computations. Lower precision reduces communication costs between processors, computation costs, and memory for storing tensors. The initial experiments, in which both the experts and the gate networks were trained in `bfloat16`, yielded more unstable training. This was, in particular, due to the router computation: as the router has an exponentiation function, having higher precision is important. To mitigate the instabilities, full precision was used for the routing as well.\n\n![Table shows that selective precision does not degrade quality.](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/04_switch_table.png) Using selective precision does not degrade quality and enables faster models\n\nThis [notebook](https://colab.research.google.com/drive/1aGGVHZmtKmcNBbAwa9hbu58DDpIuB5O4?usp=sharing) showcases fine-tuning Switch Transformers for summarization, but we suggest first reviewing the [fine-tuning section](#fine-tuning-moes).\n\nSwitch Transformers uses an encoder-decoder setup in which they did a MoE counterpart of T5. The [GLaM](https://arxiv.org/abs/2112.06905) paper explores pushing up the scale of these models by training a model matching GPT-3 quality using 1/3 of the energy (yes, thanks to the lower amount of computing needed to train a MoE, they can reduce the carbon footprint by up to an order of magnitude). The authors focused on decoder-only models and few-shot and one-shot evaluation rather than fine-tuning. They used Top-2 routing and much larger capacity factors. In addition, they explored the capacity factor as a metric one can change during training and evaluation depending on how much computing one wants to use. \n\n##  [ ](#stabilizing-training-with-router-z-loss) Stabilizing training with router Z-loss \n\nThe balancing loss previously discussed can lead to instability issues. We can use many methods to stabilize sparse models at the expense of quality. For example, introducing dropout improves stability but leads to loss of model quality. On the other hand, adding more multiplicative components improves quality but decreases stability.\n\nRouter z-loss, introduced in [ST-MoE](https://arxiv.org/abs/2202.08906), significantly improves training stability without quality degradation by penalizing large logits entering the gating network. Since this loss encourages absolute magnitude of values to be smaller, roundoff errors are reduced, which can be quite impactful for exponential functions such as the gating. We recommend reviewing the paper for details.\n\n##  [ ](#what-does-an-expert-learn) What does an expert learn? \n\nThe ST-MoE authors observed that encoder experts specialize in a group of tokens or shallow concepts. For example, we might end with a punctuation expert, a proper noun expert, etc. On the other hand, the decoder experts have less specialization. The authors also trained in a multilingual setup. Although one could imagine each expert specializing in a language, the opposite happens: due to token routing and load balancing, there is no single expert specialized in any given language.\n\n![Experts specialize in some token groups](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/05_experts_learning.png) Table from the ST-MoE paper showing which token groups were sent to which expert.\n\n##  [ ](#how-does-scaling-the-number-of-experts-impact-pretraining) How does scaling the number of experts impact pretraining? \n\nMore experts lead to improved sample efficiency and faster speedup, but these are diminishing gains (especially after 256 or 512), and more VRAM will be needed for inference. The properties studied in Switch Transformers at large scale were consistent at small scale, even with 2, 4, or 8 experts per layer.\n\n##  [ ](#fine-tuning-moes) Fine-tuning MoEs \n\n> Mixtral is supported with version 4.36.0 of transformers. You can install it with `pip install transformers==4.36.0 --upgrade`\n\nThe overfitting dynamics are very different between dense and sparse models. Sparse models are more prone to overfitting, so we can explore higher regularization (e.g. dropout) within the experts themselves (e.g. we can have one dropout rate for the dense layers and another, higher, dropout for the sparse layers). \n\nOne question is whether to use the auxiliary loss for fine-tuning. The ST-MoE authors experimented with turning off the auxiliary loss, and the quality was not significantly impacted, even when up to 11% of the tokens were dropped. Token dropping might be a form of regularization that helps prevent overfitting. \n\nSwitch Transformers observed that at a fixed pretrain perplexity, the sparse model does worse than the dense counterpart in downstream tasks, especially on reasoning-heavy tasks such as SuperGLUE. On the other hand, for knowledge-heavy tasks such as TriviaQA, the sparse model performs disproportionately well. The authors also observed that a fewer number of experts helped at fine-tuning. Another observation that confirmed the generalization issue is that the model did worse in smaller tasks but did well in larger tasks.\n\n![Fine-tuning learning curves](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/06_superglue_curves.png) In the small task (left), we can see clear overfitting as the sparse model does much worse in the validation set. In the larger task (right), the MoE performs well. This image is from the ST-MoE paper.\n\nOne could experiment with freezing all non-expert weights. That is, we'll only update the MoE layers. This leads to a huge performance drop. We could try the opposite: freezing only the parameters in MoE layers, which worked almost as well as updating all parameters. This can help speed up and reduce memory for fine-tuning. This can be somewhat counter-intuitive as 80% of the parameters are in the MoE layers (in the ST-MoE project). Their hypothesis for that architecture is that, as expert layers only occur every 1/4 layers, and each token sees at most two experts per layer, updating the MoE parameters affects much fewer layers than updating other parameters.\n\n![Only updating the non MoE layers works well in fine-tuning](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/07_superglue_bars.png) By only freezing the MoE layers, we can speed up the training while preserving the quality. This image is from the ST-MoE paper.\n\nOne last part to consider when fine-tuning sparse MoEs is that they have different fine-tuning hyperparameter setups - e.g., sparse models tend to benefit more from smaller batch sizes and higher learning rates.\n\n![Table comparing fine-tuning batch size and learning rate between dense and sparse models.](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/08_superglue_dense_vs_sparse.png) Sparse models fine-tuned quality improves with higher learning rates and smaller batch sizes. This image is from the ST-MoE paper.\n\nAt this point, you might be a bit sad that people have struggled to fine-tune MoEs. Excitingly, a recent paper, [MoEs Meets Instruction Tuning](https://arxiv.org/pdf/2305.14705.pdf) (July 2023), performs experiments doing:\n\n  * Single task fine-tuning\n  * Multi-task instruction-tuning\n  * Multi-task instruction-tuning followed by single-task fine-tuning\n\n\n\nWhen the authors fine-tuned the MoE and the T5 equivalent, the T5 equivalent was better. When the authors fine-tuned the Flan T5 (T5 instruct equivalent) MoE, the MoE performed significantly better. Not only this, the improvement of the Flan-MoE over the MoE was larger than Flan T5 over T5, indicating that MoEs might benefit much more from instruction tuning than dense models. MoEs benefit more from a higher number of tasks. Unlike the previous discussion suggesting to turn off the auxiliary loss function, the loss actually prevents overfitting.\n\n![MoEs benefit even more from instruct tuning than dense models](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/09_fine_tune_evals.png) Sparse models benefit more from instruct-tuning compared to dense models. This image is from the MoEs Meets Instruction Tuning paper\n\n##  [ ](#when-to-use-sparse-moes-vs-dense-models) When to use sparse MoEs vs dense models? \n\nExperts are useful for high throughput scenarios with many machines. Given a fixed compute budget for pretraining, a sparse model will be more optimal. For low throughput scenarios with little VRAM, a dense model will be better. \n\n**Note:** one cannot directly compare the number of parameters between sparse and dense models, as both represent significantly different things.\n\n##  [ ](#making-moes-go-brrr) Making MoEs go brrr \n\nThe initial MoE work presented MoE layers as a branching setup, leading to slow computation as GPUs are not designed for it and leading to network bandwidth becoming a bottleneck as the devices need to send info to others. This section will discuss some existing work to make pretraining and inference with these models more practical. MoEs go brrrrr.\n\n###  [ ](#parallelism) Parallelism \n\nLet’s do a brief review of parallelism:\n\n  * **Data parallelism:** the same weights are replicated across all cores, and the data is partitioned across cores.\n  * **Model parallelism:** the model is partitioned across cores, and the data is replicated across cores.\n  * **Model and data parallelism:** we can partition the model and the data across cores. Note that different cores process different batches of data.\n  * **Expert parallelism** : experts are placed on different workers. If combined with data parallelism, each core has a different expert and the data is partitioned across all cores\n\n\n\nWith expert parallelism, experts are placed on different workers, and each worker takes a different batch of training samples. For non-MoE layers, expert parallelism behaves the same as data parallelism. For MoE layers, tokens in the sequence are sent to workers where the desired experts reside.\n\n![Image illustrating model, expert, and data prallelism](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/10_parallelism.png) Illustration from the Switch Transformers paper showing how data and models are split over cores with different parallelism techniques.\n\n###  [ ](#capacity-factor-and-communication-costs) Capacity Factor and communication costs \n\nIncreasing the capacity factor (CF) increases the quality but increases communication costs and memory of activations. If all-to-all communications are slow, using a smaller capacity factor is better. A good starting point is using top-2 routing with 1.25 capacity factor and having one expert per core. During evaluation, the capacity factor can be changed to reduce compute.\n\n###  [ ](#serving-techniques) Serving techniques \n\n> You can deploy [mistralai/Mixtral-8x7B-Instruct-v0.1](https://ui.endpoints.huggingface.co/new?repository=mistralai%2FMixtral-8x7B-Instruct-v0.1&vendor=aws&region=us-east-1&accelerator=gpu&instance_size=2xlarge&task=text-generation&no_suggested_compute=true&tgi=true&tgi_max_batch_total_tokens=1024000&tgi_max_total_tokens=32000) to Inference Endpoints. \n\nA big downside of MoEs is the large number of parameters. For local use cases, one might want to use a smaller model. Let's quickly discuss a few techniques that can help with serving:\n\n  * The Switch Transformers authors did early distillation experiments. By distilling a MoE back to its dense counterpart, they could keep 30-40% of the sparsity gains. Distillation, hence, provides the benefits of faster pretaining and using a smaller model in production.\n  * Recent approaches modify the routing to route full sentences or tasks to an expert, permitting extracting sub-networks for serving.\n  * Aggregation of Experts (MoE): this technique merges the weights of the experts, hence reducing the number of parameters at inference time.\n\n\n\n###  [ ](#more-on-efficient-training) More on efficient training \n\nFasterMoE (March 2022) analyzes the performance of MoEs in highly efficient distributed systems and analyzes the theoretical limit of different parallelism strategies, as well as techniques to skew expert popularity, fine-grained schedules of communication that reduce latency, and an adjusted topology-aware gate that picks experts based on the lowest latency, leading to a 17x speedup.\n\nMegablocks (Nov 2022) explores efficient sparse pretraining by providing new GPU kernels that can handle the dynamism present in MoEs. Their proposal never drops tokens and maps efficiently to modern hardware, leading to significant speedups. What’s the trick? Traditional MoEs use batched matrix multiplication, which assumes all experts have the same shape and the same number of tokens. In contrast, Megablocks expresses MoE layers as block-sparse operations that can accommodate imbalanced assignment. \n\n![Matrix multiplication optimized for block-sparse operations.](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/moe/11_expert_matmuls.png) Block-sparse matrix multiplication for differently sized experts and number of tokens (from [MegaBlocks](https://arxiv.org/abs/2211.15841)).\n\n##  [ ](#open-source-moes) Open Source MoEs \n\nThere are nowadays several open source projects to train MoEs:\n\n  * Megablocks: <https://github.com/stanford-futuredata/megablocks>\n  * Fairseq: <https://github.com/facebookresearch/fairseq/tree/main/examples/moe_lm>\n  * OpenMoE: <https://github.com/XueFuzhao/OpenMoE>\n\n\n\nIn the realm of released open access MoEs, you can check:\n\n  * [Switch Transformers (Google)](https://huggingface.co/collections/google/switch-transformers-release-6548c35c6507968374b56d1f): Collection of T5-based MoEs going from 8 to 2048 experts. The largest model has 1.6 trillion parameters.\n  * [NLLB MoE (Meta)](https://huggingface.co/facebook/nllb-moe-54b): A MoE variant of the NLLB translation model.\n  * [OpenMoE](https://huggingface.co/fuzhao): A community effort that has released Llama-based MoEs.\n  * [Mixtral 8x7B (Mistral)](https://huggingface.co/mistralai): A high-quality MoE that outperforms Llama 2 70B and has much faster inference. A instruct-tuned model is also released. Read more about it in [the announcement blog post](https://mistral.ai/news/mixtral-of-experts/).\n\n\n\n##  [ ](#exciting-directions-of-work) Exciting directions of work \n\nFurther experiments on **distilling** a sparse MoE back to a dense model with less parameters but similar number of parameters.\n\nAnother area will be quantization of MoEs. [QMoE](https://arxiv.org/abs/2310.16795) (Oct. 2023) is a good step in this direction by quantizing the MoEs to less than 1 bit per parameter, hence compressing the 1.6T Switch Transformer which uses 3.2TB accelerator to just 160GB. \n\nSo, TL;DR, some interesting areas to explore:\n\n  * Distilling Mixtral into a dense model\n  * Explore model merging techniques of the experts and their impact in inference time\n  * Perform extreme quantization techniques of Mixtral\n\n\n\n##  [ ](#some-resources) Some resources \n\n  * [Adaptive Mixture of Local Experts (1991)](https://www.cs.toronto.edu/~hinton/absps/jjnh91.pdf)\n  * [Learning Factored Representations in a Deep Mixture of Experts (2013)](https://arxiv.org/abs/1312.4314)\n  * [Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer (2017)](https://arxiv.org/abs/1701.06538)\n  * [GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding (Jun 2020)](https://arxiv.org/abs/2006.16668)\n  * [GLaM: Efficient Scaling of Language Models with Mixture-of-Experts (Dec 2021)](https://arxiv.org/abs/2112.06905)\n  * [Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity (Jan 2022)](https://arxiv.org/abs/2101.03961)\n  * [ST-MoE: Designing Stable and Transferable Sparse Expert Models (Feb 2022)](https://arxiv.org/abs/2202.08906)\n  * [FasterMoE: modeling and optimizing training of large-scale dynamic pre-trained models(April 2022)](https://dl.acm.org/doi/10.1145/3503221.3508418)\n  * [MegaBlocks: Efficient Sparse Training with Mixture-of-Experts (Nov 2022)](https://arxiv.org/abs/2211.15841)\n  * [Mixture-of-Experts Meets Instruction Tuning:A Winning Combination for Large Language Models (May 2023)](https://arxiv.org/abs/2305.14705)\n  * [Mixtral-8x7B-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-v0.1), [Mixtral-8x7B-Instruct-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1).\n\n\n\n##  [ ](#citation) Citation \n\n```\n`@misc {sanseviero2023moe, author = { Omar Sanseviero and Lewis Tunstall and Philipp Schmid and Sourab Mangrulkar and Younes Belkada and Pedro Cuenca }, title = { Mixture of Experts Explained }, year = 2023, url = { https://huggingface.co/blog/moe }, publisher = { Hugging Face Blog } } `\n```\n\n```\n`Sanseviero, et al., \"Mixture of Experts Explained\", Hugging Face Blog, 2023. `\n```\n\nMore Articles from our Blog\n\n[ ![](/blog/assets/segmoe/thumbnail.png) SegMoE: Segmind Mixture of Diffusion Experts By [Warlord-K](/Warlord-K) February 3, 2024 guest • 7](/blog/segmoe)\n\n[ ![](/blog/assets/mixtral/thumbnail.jpg) Welcome Mixtral - a SOTA Mixture of Experts on Hugging Face By [lewtun](/lewtun) December 11, 2023 • 11](/blog/mixtral)\n\n### Community\n\nEditPreview\n\nUpload images, audio, and videos by dragging in the text input, pasting, or clicking here.\n\nTap or paste here to upload images\n\nComment\n\n· [Sign up](/join?next=%2Fblog%2Fmoe) or [log in](/login?next=%2Fblog%2Fmoe) to comment\n\n[ Upvote 262 ](/login?next=%2Fblog%2Fmoe)\n\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1583857146757-5e67bdd61009063689407479.jpeg)](/clem \"clem\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1585493970035-noauth.jpeg)](/maveriq \"maveriq\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/5edf9030636bdb3834e2da08/At8kxNZmG7ZWuxx7P3dlM.png)](/erinkhoo \"erinkhoo\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1594311341799-5f07383b19cb630495b812cd.jpeg)](/stas \"stas\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/5f43448a79c1ba4c353d0d8f/DiSygV3dn7A_OjmGVTrHD.jpeg)](/sugatoray \"sugatoray\")\n  * [![](/avatars/42b34eda17abafaba2c96906cecc9c73.svg)](/Shivangsharma \"Shivangsharma\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/1637335546726-5fff7edf6a2a91af974298c8.jpeg)](/shamikbose89 \"shamikbose89\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/6032802e1f993496bc14d9e3/w6hr-DEQot4VVkoyRIBiy.png)](/osanseviero \"osanseviero\")\n  * [![](/avatars/63ff3a2ce469da0f59e9ef501250a136.svg)](/catqaq \"catqaq\")\n  * [![](/avatars/a6cf48befd61b49d24286350f3c894c4.svg)](/kazuakey \"kazuakey\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/60952b052d2f414712f0c235/4lwyxRxXFYXRmUxt_DkOD.jpeg)](/lennert \"lennert\")\n  * [![](https://cdn-avatars.huggingface.co/v1/production/uploads/60ad12f355f970745d4ec28f/TCJiFQck_tzWc_y4-nmTB.png)](/tryumanshow \"tryumanshow\")\n  * +250\n\n\n\nSystem theme \n\nCompany\n\n[TOS](/terms-of-service) [Privacy](/privacy) [About](/huggingface) [Jobs](https://apply.workable.com/huggingface/) [](/)\n\nWebsite\n\n[Models](/models) [Datasets](/datasets) [Spaces](/spaces) [Pricing](/pricing) [Docs](/docs)\n",
    "content_quality_score": 1.0,
    "summary": null,
    "child_urls": [
        "https://huggingface.co/",
        "https://huggingface.co/models",
        "https://huggingface.co/datasets",
        "https://huggingface.co/spaces",
        "https://huggingface.co/posts",
        "https://huggingface.co/docs",
        "https://huggingface.co/enterprise",
        "https://huggingface.co/pricing",
        "https://huggingface.co/login",
        "https://huggingface.co/join",
        "https://huggingface.co/blog",
        "https://huggingface.co/blog/moe/#mixture-of-experts-explained",
        "https://huggingface.co/login?next=%2Fblog%2Fmoe",
        "https://huggingface.co/clem",
        "https://huggingface.co/maveriq",
        "https://huggingface.co/erinkhoo",
        "https://huggingface.co/stas",
        "https://huggingface.co/sugatoray",
        "https://huggingface.co/Shivangsharma",
        "https://huggingface.co/osanseviero",
        "https://huggingface.co/lewtun",
        "https://huggingface.co/philschmid",
        "https://huggingface.co/smangrul",
        "https://huggingface.co/ybelkada",
        "https://huggingface.co/pcuenq",
        "https://huggingface.co/blog/moe/#table-of-contents",
        "https://huggingface.co/blog/moe/#tldr",
        "https://huggingface.co/blog/moe/#what-is-a-mixture-of-experts-moe",
        "https://huggingface.co/blog/moe/#a-brief-history-of-moes",
        "https://huggingface.co/blog/moe/#what-is-sparsity",
        "https://huggingface.co/blog/moe/#load-balancing-tokens-for-moes",
        "https://huggingface.co/blog/moe/#moes-and-transformers",
        "https://huggingface.co/blog/moe/#switch-transformers",
        "https://huggingface.co/blog/moe/#stabilizing-training-with-router-z-loss",
        "https://huggingface.co/blog/moe/#what-does-an-expert-learn",
        "https://huggingface.co/blog/moe/#how-does-scaling-the-number-of-experts-impact-pretraining",
        "https://huggingface.co/blog/moe/#fine-tuning-moes",
        "https://huggingface.co/blog/moe/#when-to-use-sparse-moes-vs-dense-models",
        "https://huggingface.co/blog/moe/#making-moes-go-brrr",
        "https://huggingface.co/blog/moe/#parallelism",
        "https://huggingface.co/blog/moe/#capacity-factor-and-communication-costs",
        "https://huggingface.co/blog/moe/#serving-techniques",
        "https://huggingface.co/blog/moe/#more-on-efficient-training",
        "https://huggingface.co/blog/moe/#open-source-moes",
        "https://huggingface.co/blog/moe/#exciting-directions-of-work",
        "https://huggingface.co/blog/moe/#some-resources",
        "https://huggingface.co/blog/moe/#citation",
        "https://huggingface.co/mistralai/Mixtral-8x7B-v0.1",
        "https://huggingface.co/google/switch-c-2048",
        "https://ui.endpoints.huggingface.co/new?repository=mistralai%2FMixtral-8x7B-Instruct-v0.1&vendor=aws&region=us-east-1&accelerator=gpu&instance_size=2xlarge&task=text-generation&no_suggested_compute=true&tgi=true&tgi_max_batch_total_tokens=1024000&tgi_max_total_tokens=32000",
        "https://huggingface.co/collections/google/switch-transformers-release-6548c35c6507968374b56d1f",
        "https://huggingface.co/facebook/nllb-moe-54b",
        "https://huggingface.co/fuzhao",
        "https://huggingface.co/mistralai",
        "https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1",
        "https://huggingface.co/blog/segmoe",
        "https://huggingface.co/Warlord-K",
        "https://huggingface.co/blog/mixtral",
        "https://huggingface.co/join?next=%2Fblog%2Fmoe",
        "https://huggingface.co/shamikbose89",
        "https://huggingface.co/catqaq",
        "https://huggingface.co/kazuakey",
        "https://huggingface.co/lennert",
        "https://huggingface.co/tryumanshow",
        "https://huggingface.co/terms-of-service",
        "https://huggingface.co/privacy",
        "https://huggingface.co/huggingface",
        "https://github.com/huggingface/blog/blob/main/moe.md",
        "https://mistral.ai/news/mixtral-of-experts/",
        "https://arxiv.org/pdf/2305.14705.pdf",
        "https://www.cs.toronto.edu/~hinton/absps/jjnh91.pdf",
        "https://arxiv.org/abs/1312.4314",
        "https://arxiv.org/abs/1701.06538",
        "https://www.informatika.bg/jeffdean",
        "https://arxiv.org/abs/2006.16668",
        "https://arxiv.org/abs/2101.03961",
        "https://colab.research.google.com/drive/1aGGVHZmtKmcNBbAwa9hbu58DDpIuB5O4?usp=sharing",
        "https://arxiv.org/abs/2112.06905",
        "https://arxiv.org/abs/2202.08906",
        "https://github.com/stanford-futuredata/megablocks",
        "https://github.com/facebookresearch/fairseq/tree/main/examples/moe_lm",
        "https://github.com/XueFuzhao/OpenMoE",
        "https://arxiv.org/abs/2310.16795",
        "https://dl.acm.org/doi/10.1145/3503221.3508418",
        "https://arxiv.org/abs/2211.15841",
        "https://arxiv.org/abs/2305.14705",
        "https://apply.workable.com/huggingface/"
    ]
}