{
    "id": "ac95609a9de05aa0cb37b8dff48b8dfa",
    "metadata": {
        "id": "ac95609a9de05aa0cb37b8dff48b8dfa",
        "url": "https://www.notion.so/LLM-Inference-Optimization-Other-Techniques-ac95609a9de05aa0cb37b8dff48b8dfa",
        "title": "LLM Inference Optimization & Other Techniques",
        "properties": {
            "Type": "Leaf"
        }
    },
    "parent_metadata": {
        "id": "74f874faa52cc8aba7f2a2519264e8bf",
        "url": "",
        "title": "",
        "properties": {}
    },
    "content": "# Notes\n\n\n\n<child_page>\n# Main LLM optimization techniques\n\nDirectly supported by LLM inference engines (e.g., vLLM, TGI, TensorRT-LLM):\n- Caching:\n\t- KV-caching\n\t- prompt caching (in memory, disk or semantic)\n\n- Compilers:\n\t- torch.compile()\n\t- TensorRT\n\n- Continuous batching\n- Speculative decoding\n- Optimized attention mechanisms\n\t- PagedAttention\n\t- FlashAttention\n\n- Model parallelism\n\t- data\n\t- pipeline (lower VRAM)\n\t- tensor (lower latency)\n\n\nAdditional steps before loading LLMs into inference engines:\n- Quantization:\n\t- GGUF - optimized for CPU\n\t- GPTQ, EXL2, AWQ - optimized for GPU\n</child_page>\n\n\n\n<child_page>\n# Speculative Decoding: A Guide With Implementation Examples\n\n[https://www.datacamp.com/tutorial/speculative-decoding](https://www.datacamp.com/tutorial/speculative-decoding)\n# Summary\n\n\n\n\n# Notes\n\nLet's break down the process of speculative decoding into simple steps:\n- ​Draft generation: The smaller model (e.g., Gemma2-2B-it) generates multiple token suggestions based on the input prompt. These tokens are generated speculatively, meaning the model is not certain they are correct but provides them as “draft” tokens.\n- Parallel ​verification: The larger model (e.g., Gemma2-9B-it) verifies these tokens in parallel, checking their probability against the model’s learned distribution. If the tokens are deemed acceptable, they are used in the final output. If not, the larger model corrects them.\n- ​Final output: Once the tokens are verified (or corrected), they are passed on to the user as the final output. This entire process happens much faster than traditional one-token-at-a-time decoding.\n[Image](No URL)\nThis can reduce response time by 30-40%, cutting latency from 25-30 seconds to as little as 15-18 seconds.\nAdditionally, speculative decoding optimizes memory usage by shifting most of the token generation to the smaller model, reducing memory requirements from 26 GB to around 14 GB and making [on-device](https://www.datacamp.com/blog/edge-ai) inference more accessible.\nFinally, it lowers compute demands by 50%, as the larger model only verifies rather than generates tokens, enabling smoother performance on mobile devices with limited power and preventing overheating.\n```\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, set_seed\n\n\ndef speculative_decoding(small_model, big_model, small_tokenizer, big_tokenizer, prompt, max_new_tokens=50):\n    # Step 1: Use the small model to generate the draft\n    inputs = small_tokenizer(prompt, return_tensors='pt').to(device)\n    small_outputs = small_model.generate(inputs['input_ids'], max_new_tokens=max_new_tokens)\n    draft = small_tokenizer.decode(small_outputs[0], skip_special_tokens=True)\n\n    # Step 2: Verify the draft with the big model\n    big_inputs = big_tokenizer(draft, return_tensors='pt').to(device)\n\n    # Step 3: Calculate log-likelihood of the draft tokens under the large model\n    with torch.no_grad():\n        outputs = big_model(big_inputs['input_ids'])\n        log_probs = torch.log_softmax(outputs.logits, dim=-1)\n\n    draft_token_ids = big_inputs['input_ids']\n    log_likelihood = 0\n    for i in range(draft_token_ids.size(1) - 1):\n        token_id = draft_token_ids[0, i + 1]\n        log_likelihood += log_probs[0, i, token_id].item()\n\n    avg_log_likelihood = log_likelihood / (draft_token_ids.size(1) - 1)\n\n    # Return the draft and its log-likelihood score\n    return draft, avg_log_likelihood\n````\n</child_page>\n\n\n\n<child_page>\n# Optimizing LLMs for Speed and Memory\n\n [https://huggingface.co/docs/transformers/en/llm_tutorial_optimization](https://huggingface.co/docs/transformers/en/llm_tutorial_optimization)\n# Summary\n\n\n\n---\n\n\nIn this guide, we will go over the effective techniques for efficient LLM deployment:\n- Lower Precision (quantization): Research has shown that operating at reduced numerical precision, namely [8-bit and 4-bit](https://huggingface.co/docs/transformers/en/main_classes/quantization.md) can achieve computational advantages without a considerable decline in model performance.\n- Flash Attention: Flash Attention is a variation of the attention algorithm that not only provides a more memory-efficient approach but also realizes increased efficiency due to optimized GPU memory utilization.\n- Architectural Innovations: Considering that LLMs are always deployed in the same way during inference, namely autoregressive text generation with a long input context, specialized model architectures have been proposed that allow for more efficient inference. The most important advancement in model architectures hereby are [Alibi](https://arxiv.org/abs/2108.12409), [Rotary embeddings](https://arxiv.org/abs/2104.09864), [Multi-Query Attention (MQA)](https://arxiv.org/abs/1911.02150) and [Grouped-Query-Attention (GQA)](https://huggingface.co/docs/transformers/en/(https://arxiv.org/abs/2305.13245)).\n\n# Lower Precision\n\n“Loading the weights of a model having X billion parameters requires roughly 4 X GB of VRAM in float32 precision*\n“Loading the weights of a model having X billion parameters requires roughly 2 X GB of VRAM in bfloat16/float16 precision*\n\n# Flash Attention\n\nBy keeping track of softmax normalization statistics and by using some smart mathematics, Flash Attention gives numerical identical outputs compared to the default self-attention layer at a memory cost that only increases linearly with N.\nFlash Attention is much faster in inference compared to default attention which comes from its ability to significantly reduce the demands on the slower, high-bandwidth memory of the GPU (VRAM), focusing instead on the faster on-chip memory (SRAM).\nEssentially, Flash Attention makes sure that all intermediate write and read operations can be done using the fast on-chip SRAM memory instead of having to access the slower VRAM memory to compute the output vector O.\nIn practice, there is currently absolutely no reason to not use Flash Attention if available. The algorithm gives mathematically the same outputs, and is both faster and more memory-efficient.\n```\nmodel.to_bettertransformer()\n\nstart_time = time.time()\nwith torch.backends.cuda.sdp_kernel(enable_flash=True, enable_math=False, enable_mem_efficient=False):\n    result = pipe(long_prompt, max_new_tokens=60)[0][\"generated_text\"][len(long_prompt):]\n\nprint(f\"Generated in {time.time() - start_time} seconds.\")\n````\n\n# Architectural Innovations\n\nLet’s now look into how we can change the architecture of an LLM so that it is most effective and efficient for task that require long text inputs, e.g.:\n- Retrieval augmented Questions Answering,\n- Summarization,\n- Chat\nNote that chat not only requires the LLM to handle long text inputs, but it also necessitates that the LLM is able to efficiently handle the back-and-forth dialogue between user and assistant (such as ChatGPT).\n\nTwo important components of the model architecture that quickly become memory and/or performance bottlenecks for large input sequences:\n- The positional embeddings\n- The key-value cache\n\n# Improving positional embeddings of LLMs\n\nSinusoidal and learned position embeddings used to be the predominant methods to encode sentence order into LLMs, but a couple of problems related to these positional encodings were found:\n- Sinusoidal and learned position embeddings are both absolute positional embeddings: lead to poor LLM performance for long text inputs. For long text inputs, it is advantageous if the model learns the relative positional distance input tokens have to each other instead of their absolute position.\n- When using learned position embeddings, the LLM has to be trained on a fixed input lengthN, which makes it difficult to extrapolate to an input length longer than what it was trained on.\nRecently, relative positional embeddings that can tackle the above mentioned problems have become more popular, most notably:\n- [Rotary Position Embedding (RoPE)](https://arxiv.org/abs/2104.09864)\n- [ALiBi](https://arxiv.org/abs/2108.12409)\nBoth RoPE and ALiBi argue that it’s best to cue the LLM about sentence order directly in the self-attention algorithm as it’s there that word tokens are put into relation with each other. More specifically, sentence order should be cued by modifying the QKT computation.\nRoPE notes that positional information can be encoded into query-key pairs by rotating each vector by an angle.\nRoPE is used in multiple of today’s most important LLMs, such as:\n- [Falcon](https://huggingface.co/tiiuae/falcon-40b)\n- [Llama](https://arxiv.org/abs/2302.13971)\n- [PaLM](https://arxiv.org/abs/2204.02311)\nAs an alternative, ALiBi proposes a much simpler relative position encoding scheme. The relative distance that input tokens have to each other is added as a negative integer scaled by a pre-defined value m to each query-key entry of the QKT matrix right before the softmax computation.\n[Image](No URL)\nALiBi is used in multiple of today’s most important LLMs, such as:\n- [MPT](https://huggingface.co/mosaicml/mpt-30b)\n- [BLOOM](https://huggingface.co/bigscience/bloom)\nBoth RoPE and ALiBi position encodings can extrapolate to input lengths not seen during training whereas it has been shown that extrapolation works much better out-of-the-box for ALiBi as compared to RoPE.\nFor RoPE , keeping the same θ that was used during training leads to poor results when passing text inputs much longer than those seen during training\nThe further text input tokens are from each other, the lower the probability of their query-value probability. Both RoPE and ALiBi lower the query-key probability of tokens far away from each other. RoPE by decreasing their vector product by increasing the angle between the query-key vectors. ALiBi by adding large negative numbers to the vector product\nnote that even if an LLM with RoPE and ALiBi has been trained only on a fixed length of say N1=2048 it can still be used in practice with text inputs much larger than N1, like N2=8192>N1 by extrapolating the positional embeddings.\n\n# The key-value cache\n\n```\npast_key_values = None # past_key_values is the key-value cache\ngenerated_tokens = []\nnext_token_id = tokenizer(prompt, return_tensors=\"pt\")[\"input_ids\"].to(\"cuda\")\n\nfor _ in range(5):\n  next_logits, past_key_values = model(next_token_id, past_key_values=past_key_values, use_cache=True).to_tuple()\n  next_logits = next_logits[:, -1:]\n  next_token_id = torch.argmax(next_logits, dim=-1)\n\n  print(\"shape of input_ids\", next_token_id.shape)\n  print(\"length of key-value cache\", len(past_key_values[0][0]))  # past_key_values are of shape [num_layers, 0 for k, 1 for v, batch_size, length, hidden_dim]\n  generated_tokens.append(next_token_id.item())\n\ngenerated_text = tokenizer.batch_decode(generated_tokens)\ngenerated_text\n````\nOutput:\n```\nshape of input_ids torch.Size([1, 1])\nlength of key-value cache 20\nshape of input_ids torch.Size([1, 1])\nlength of key-value cache 21\nshape of input_ids torch.Size([1, 1])\nlength of key-value cache 22\nshape of input_ids torch.Size([1, 1])\nlength of key-value cache 23\nshape of input_ids torch.Size([1, 1])\nlength of key-value cache 24\n````\nAs one can see, when using the key-value cache the text input tokens are not increased in length, but remain a single input vector. The length of the key-value cache on the other hand is increased by one at every decoding step.\nMaking use of the key-value cache means that the QKT is essentially reduced to qcKT with qc being the query projection of the currently passed input token which is always just a single vector.\nUsing the key-value cache has two advantages:\n- Significant increase in computational efficiency as less computations are performed compared to computing the fullQKT matrix. This leads to an increase in inference speed\n\tQKT\n\n- The maximum required memory is not increased quadratically with the number of generated tokens, but only increases linearly.\n“One should always make use of the key-value cache as it leads to identical results and a significant speed-up for longer input sequences.”\nNote that, despite our advice to use key-value caches, your LLM output may be slightly different when you use them. This is a property of the matrix multiplication kernels themselves.\n\n# Multi-round conversation\n\nThe key-value cache is especially useful for applications such as chat where multiple passes of auto-regressive decoding are required.\nTwo things should be noted here:\n- Keeping all the context is crucial for LLMs deployed in chat so that the LLM understands all the previous context of the conversation. \n- The key-value cache is extremely useful for chat as it allows us to continuously grow the encoded chat history instead of having to re-encode the chat history again from scratch (as e.g. would be the case when using an encoder-decoder architecture).\nExample on how to use previous key-value results from a different generation step:\n```\n# Generation as usual\nprompt = system_prompt + \"Question: Please write a function in Python that transforms bytes to Giga bytes.\\n\\nAnswer: Here\"\nmodel_inputs = tokenizer(prompt, return_tensors='pt')\ngeneration_output = model.generate(**model_inputs, max_new_tokens=60, return_dict_in_generate=True)\ndecoded_output = tokenizer.batch_decode(generation_output.sequences)[0]\n\n# Piping the returned `past_key_values` to speed up the next conversation round\nprompt = decoded_output + \"\\nQuestion: How can I modify the function above to return Mega bytes instead?\\n\\nAnswer: Here\"\nmodel_inputs = tokenizer(prompt, return_tensors='pt')\ngeneration_output = model.generate(\n  **model_inputs,\n  past_key_values=generation_output.past_key_values,\n  max_new_tokens=60,\n  return_dict_in_generate=True\n)\ntokenizer.batch_decode(generation_output.sequences)[0][len(prompt):]\n````\nOutput:\n```\n is a modified version of the function that returns Mega bytes instead.\n\ndef bytes_to_megabytes(bytes):\n   return bytes / 1024 / 1024\n\nAnswer: The function takes a number of bytes as input and returns the number of\n````\nThere is however one catch: holding the key-value cache in memory can become very memory expensive for long input sequences or multi-turn chat.\nComputing this for our LLM at a hypothetical input sequence length of 16000 gives:\n```\nconfig = model.config # bigcode/octocoder\n2 * 16_000 * config.n_layer * config.n_head * config.n_embd // config.n_head\n````\nRoughly 8 billion float values! Storing 8 billion float values in float16 precision requires around 15 GB of RAM\n# Multi-Query-Attention (MQA)\n\nNoam found out that instead of using n_head key-value projections weights, one can use a single head-value projection weight pair that is shared across all attention heads without that the model’s performance significantly degrades.\nAs most LLMs use between 20 and 100 attention heads, MQA significantly reduces the memory consumption of the key-value cache.\nIn addition to memory savings, MQA also leads to improved computational efficiency\nMQA has seen wide adoption by the community and is now used by many of the most popular LLMs:\n- [Falcon](https://huggingface.co/tiiuae/falcon-40b)\n- [PaLM](https://arxiv.org/abs/2204.02311)\n- [MPT](https://huggingface.co/mosaicml/mpt-30b)\n- [BLOOM](https://huggingface.co/bigscience/bloom)\n# Grouped-Query-Attention (GQA)\n\n[Grouped-Query-Attention](https://arxiv.org/abs/2305.13245), as proposed by Ainslie et al. from Google, found that using MQA can often lead to quality degradation compared to using vanilla multi-key-value head projections. \n Instead of using just a single key-value projection weight, n < n_head key-value projection weights should be used.\nBy choosing n to a significantly smaller value than n_head, such as 2,4 or 8 almost all of the memory and speed gains from MQA can be kept while sacrificing less model capacity and thus arguably less performance.\nGQA was only recently proposed which is why there is less adoption at the time of writing this notebook. The most notable application of GQA is [Llama-v2](https://huggingface.co/meta-llama/Llama-2-70b-hf).\n\nAs a conclusion, it is strongly recommended to make use of either GQA or MQA if the LLM is deployed with auto-regressive decoding and is required to handle large input sequences as is the case for example for chat.\n</child_page>\n\n\n\n<child_page>\n# Continuous vs dynamic batching for AI inference\n\n[https://www.baseten.co/blog/continuous-vs-dynamic-batching-for-ai-inference/](https://www.baseten.co/blog/continuous-vs-dynamic-batching-for-ai-inference/)\n# Summary\n\n\n\n\n# Notes\n\nThere are four ways inference requests can be batched on a GPU:\n- No batching: each request is processed one at a time.\n- Static batching: requests are placed in batches that are run when full.\n- Dynamic batching: requests are placed in batches as they’re received and batches run once full or once enough time has elapsed since the first request.\n- Continuous batching: requests are processed token-by-token, with new requests getting processed as older requests finish and free up space on the GPU.\nBatching method depends on model architecture and modality. In production, you’ll generally want continuous batching for LLMs and dynamic batching for most other generative models.\n\nWhen running inference on an LLM, or many other ML models, your bottleneck is the memory bandwidth used to load model weights. Model weights are much bigger than the activations (which are the \"state\" of a request mid-processing), so when loading a single layer of weights into the GPU's cache, you want to share that cost across processing many independent sets of activations.\n\nStatic batching works well for daily jobs or behind-the-scenes processing. But for latency-sensitive production deployments, like generating images in response to user input, static batching won’t cut it.\n\nDynamic batching works the same way. You set up dynamic batching with:\n- A preset maximum batch size, which you hope to reach before kicking off each run.\n- A window to wait after receiving the first request before running a partial batch.\n\nDynamic batching is great for live traffic on models like [Stable Diffusion XL](https://www.baseten.co/library/stable-diffusion-xl/), where each inference request takes about the same amount of time.\n\nWhile dynamic batching is great for modalities like image generation where each output takes about the same amount of time to create, we can do even better for LLMs with continuous batching.\n\nContinuous batching works at the token level rather than at the request level. The bottleneck in LLM inference is loading model weights. So for continuous batching, the model server loads each layer of the model sequentially and applies it to the next token of each request. In continuous batching, the same model weights could be used to generate the fifth token of one response and the eighty-fifth token of another.\n[Image](No URL)\nLike with dynamic batching, you need to configure continuous batching based on your anticipated traffic patterns. You need to specify:\n- Maximum batch size: how many requests the model can process at once.\n- Anticipated sequence shapes: how many tokens the input and output sequences are expected to contain.\nContinuous batching is implemented at the inference server layer. Model servers like TGI and VLLM offer continuous batching, while TensorRT-LLM uses “in-flight batching” to essentially the same effect.\n</child_page>\n\n\n\n<child_page>\n# RoPE (Rotary Position Embedding) Scaling \n\nRoPE (Rotary Position Embedding) Scaling is a technique used to extend the context window of Large Language Models (LLMs) during training and inference, enabling them to process sequences longer than their original training length. It addresses the challenge of maintaining positional awareness and model performance when handling longer input sequences without retraining the model from scratch.\n---\n\n# What Problem Does RoPE Scaling Solve?\n\nTransformers rely on position embeddings to understand token order. Standard RoPE encodes positions by rotating query/key vectors using sinusoidal functions. However, when a model trained on sequences of length L (e.g., 4k tokens) encounters inputs longer than L during inference, its positional understanding breaks down, leading to poor performance. RoPE Scaling modifies the original RoPE mechanism to generalize better to longer sequences.\n---\n\n# How RoPE Works (Brief Recap)\n\n- Rotary Position Embedding (RoPE) injects positional information by rotating the query (Q) and key (K) vectors in the attention mechanism using complex-number rotations. The rotation angle depends on the token's position.\n- Mathematically, for a token at position m, the rotation is applied as:\n\\[\nQ_m = Q \\cdot e^{i m \\theta}, \\quad K_n = K \\cdot e^{i n \\theta}\n\\]\nwhere θ is a frequency parameter. The dot product Q_m · K_n then inherently encodes the relative distance (m − n).\n---\n\n# RoPE Scaling Techniques\n\nTo adapt RoPE for longer sequences, the rotation mechanism is adjusted by modifying the frequency parameters (θ) or interpolation strategies. Common methods include:\n- Linear Scaling (Position Interpolation):\n\t- Compresses the position indices of longer sequences into the original training range.\n\t- Example: For a model trained on 2048 tokens, scaling to 8192 tokens would divide position indices by 4 (interpolating positions).\n\t- Used in models like LLaMA 2 (extending context from 4k → 8k/16k).\n\n- NTK-Aware Scaling:\n\t- Based on Neural Tangent Kernel (NTK) theory, it gradually increases high-frequency resolution while preserving low-frequency information.\n\t- Instead of directly interpolating positions, it tweaks the base frequency θ to balance short- and long-range attention.\n\n- Dynamic NTK Scaling:\n\t- Dynamically adjusts the interpolation factor based on input length.\n\t- For shorter sequences (≤ trained length), uses original RoPE. For longer sequences, applies NTK-aware scaling.\n\n- YaRN (Yet another RoPE extensioN):\n\t- Combines NTK-aware scaling with \"temperature\" tuning to minimize degradation in attention patterns.\n\t- Achieves strong performance for extreme extrapolation (e.g., 128k context in Mistral 7B).\n\n---\n\n# Why It Matters for LLMs\n\n- Longer Context: Enables models to process books, codebases, or multi-document inputs.\n- Efficiency: Avoids full retraining on longer sequences (costly for large models).\n- Zero-Shot Adaptation: Many LLMs (e.g., LLaMA, GPT-NeoX) can use RoPE scaling during inference with minimal code changes.\n---\n\n# Technical Intuition\n\n- Frequency Bands: RoPE assigns different frequencies to positions. Scaling adjusts these frequencies to avoid \"spectral distortion\" when extrapolating.\n- Interpolation vs. Extrapolation:\n\t- Naive extrapolation (using positions beyond training length) causes attention scores to degrade.\n\t- Scaling \"stretches\" the frequency spectrum to cover longer sequences smoothly.\n\n(Analogy: Imagine stretching a spring. Linear scaling compresses the spring, while NTK-aware scaling adjusts its stiffness to avoid breaking.)\n---\n\n# Challenges\n\n- Loss of High-Frequency Details: Aggressive scaling can blur fine-grained positional relationships.\n- Calibration: Requires balancing interpolation strength to avoid performance drops.\n- Attention Head Variance: Some attention heads are more sensitive to positional changes than others.\n---\n\n# Applications\n\n- Code Completion: Handling long code files.\n- Document Analysis: Summarizing/researching multi-page texts.\n- Chatbots: Retaining context over long conversations.\nModels like CodeLlama, Mistral 7B, and Yi-34B use variants of RoPE scaling to achieve context windows up to 200k tokens.\n---\n\n# Key Takeaway\n\nRoPE Scaling is a clever computational tweak to the positional encoding mechanism, enabling LLMs to generalize to longer sequences without retraining. It bridges the gap between fixed-context training and variable-context real-world use cases.\n</child_page>\n\n\n---\n\n# Resources [Community]\n\n\t[https://steelph0enix.github.io/posts/llama-cpp-guide](https://steelph0enix.github.io/posts/llama-cpp-guide)\n\t[https://www.datacamp.com/tutorial/speculative-decoding](https://www.datacamp.com/tutorial/speculative-decoding)\n\t[https://www.baseten.co/blog/continuous-vs-dynamic-batching-for-ai-inference/](https://www.baseten.co/blog/continuous-vs-dynamic-batching-for-ai-inference/)\n\t[https://huggingface.co/docs/transformers/en/llm_tutorial_optimization](https://huggingface.co/docs/transformers/en/llm_tutorial_optimization)\n\t[https://www.youtube.com/watch?v=sNv5jpAwkcU](https://www.youtube.com/watch?v=sNv5jpAwkcU)\n\n# Resources [Science]\n\n\t\n\n# Tools\n\n\t# Quantization\n\t\n\t[Link Preview](https://github.com/ggerganov/llama.cpp)\n\t[Link Preview](https://github.com/turboderp/exllamav2)\n\t [AutoQuant](https://colab.research.google.com/drive/1b6nqC7UZVt8bx4MksX7s656GXPM-eWw4?usp=sharing#scrollTo=fD24jJxq7t3k)",
    "content_quality_score": null,
    "summary": null,
    "child_urls": [
        "https://colab.research.google.com/drive/1b6nqC7UZVt8bx4MksX7s656GXPM-eWw4?usp=sharing#scrollTo=fD24jJxq7t3k/",
        "https://huggingface.co/docs/transformers/en/main_classes/quantization.md/",
        "https://arxiv.org/abs/1911.02150/",
        "https://www.datacamp.com/blog/edge-ai/",
        "https://arxiv.org/abs/2104.09864/",
        "https://github.com/ggerganov/llama.cpp/",
        "https://huggingface.co/meta-llama/Llama-2-70b-hf/",
        "https://arxiv.org/abs/2204.02311/",
        "https://steelph0enix.github.io/posts/llama-cpp-guide/",
        "https://arxiv.org/abs/2302.13971/",
        "https://huggingface.co/docs/transformers/en/(https://arxiv.org/abs/2305.13245)/",
        "https://www.youtube.com/watch?v=sNv5jpAwkcU/",
        "https://arxiv.org/abs/2108.12409/",
        "https://huggingface.co/mosaicml/mpt-30b/",
        "https://huggingface.co/tiiuae/falcon-40b/",
        "https://arxiv.org/abs/2305.13245/",
        "https://huggingface.co/docs/transformers/en/llm_tutorial_optimization/",
        "https://github.com/turboderp/exllamav2/",
        "https://www.datacamp.com/tutorial/speculative-decoding/",
        "https://www.baseten.co/blog/continuous-vs-dynamic-batching-for-ai-inference/",
        "https://www.baseten.co/library/stable-diffusion-xl/",
        "https://huggingface.co/bigscience/bloom/"
    ]
}